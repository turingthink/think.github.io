# 第二部分：迷宫游戏进阶——碰撞检测与关卡设计  
## 课题  
让游戏“有规则”：墙壁碰撞与多关卡迷宫  


## 教学时间  
2课时（90分钟）  


## 课前准备  
- **教师端**：电脑（含前两课时代码、碰撞检测演示程序）、投影仪、多媒体课件（含碰撞检测原理动画：如矩形重叠检测）、“迷宫关卡卡片”（2张不同复杂度的网格迷宫）。  
- **学生端**：电脑（保存前两课时的角色移动代码）、上次课手绘的迷宫地图、笔记本（记录碰撞逻辑要点）、彩色笔（标注关卡难点）。  
- **教学素材**：碰撞检测代码模板、多关卡地图数据（用列表表示墙壁位置）、AI代码小助手（预设“碰撞逻辑”“关卡切换”等问题的解答）。  


## 一、导入活动：从“无规则移动”到“有边界游戏”（15分钟）  
## 活动1：“盲人摸墙”体验——理解碰撞意义  
- 学生蒙眼在教室划定区域内行走，碰到障碍物（如椅子）需停下：“游戏中角色碰到墙壁也要停下，否则会‘穿墙’——这就是碰撞检测”。  
- 提问：“怎么判断‘碰到墙’？”引导学生发现“角色和墙的位置重叠了”。  

## 活动2：“迷宫关卡分析”——拆解关卡元素  
- 展示“迷宫关卡卡片”：简单关卡（3面墙）和复杂关卡（多面墙+岔路）。  
- 小组讨论：“要让代码实现这张地图，需要告诉计算机‘哪些位置是墙’？”（用坐标标注墙的位置）。  


## 二、知识点讲解：碰撞检测与关卡设计（35分钟）  
## 模块1：定义墙壁——用列表存储“禁止区域”（10分钟）  
- **墙壁的数据形式**：用列表存储多个矩形（`pygame.Rect`），每个矩形代表一面墙，类比“在地图上画禁止通行的线”：  
  ```python
  # 定义迷宫墙壁（简单关卡：4面墙）
  walls = [
      pygame.Rect(0, 0, 600, 20),  # 顶部墙（x=0,y=0,宽=600,高=20）
      pygame.Rect(0, 0, 20, 400),  # 左侧墙
      pygame.Rect(580, 0, 20, 400),  # 右侧墙
      pygame.Rect(0, 380, 600, 20)  # 底部墙
  ]
  ```  
- **绘制墙壁**：在主循环中用`pygame.draw.rect()`批量绘制，颜色设为灰色（与背景区分）：  
  ```python
  # 在刷新画面部分添加
  for wall in walls:
      pygame.draw.rect(screen, (100, 100, 100), wall)  # 灰色墙壁
  ```  

## 模块2：碰撞检测——判断“角色是否碰到墙”（15分钟）  
- **核心逻辑**：用`player.collidelist(walls)`检测角色与墙壁的重叠，返回-1表示无碰撞，否则表示碰到第n面墙：  
  ```python
  # 在移动逻辑后添加碰撞检测
  # 1. 先记录移动前的位置
  old_x, old_y = player.x, player.y
  # 2. 处理移动（上下左右）
  if keys[pygame.K_UP]:
      player.y -= 3
  # （省略下、左、右移动代码）
  # 3. 检测碰撞：如果碰到墙，就回到移动前的位置
  if player.collidelist(walls) != -1:
      player.x, player.y = old_x, old_y  # 回退位置（不穿墙）
  ```  
- **原理动画**：播放矩形重叠动画，说明“当角色矩形和墙壁矩形有重叠时，就触发碰撞，禁止移动”。  

## 模块3：关卡切换——从“简单”到“复杂”（10分钟）  
- **关卡数据封装**：用函数定义不同关卡的墙壁，类比“换地图就是换一组墙壁数据”：  
  ```python
  def get_level1_walls():
      # 第一关：外围墙+1个中间墙
      return [
          pygame.Rect(0, 0, 600, 20),
          pygame.Rect(0, 0, 20, 400),
          pygame.Rect(580, 0, 20, 400),
          pygame.Rect(0, 380, 600, 20),
          pygame.Rect(200, 100, 20, 200)  # 中间竖墙
      ]

  def get_level2_walls():
      # 第二关：更复杂的墙壁（学生可自定义）
      return [
          pygame.Rect(0, 0, 600, 20),
          # ... 更多墙壁
      ]
  ```  
- **切换逻辑**：用变量`current_level`记录当前关卡，碰到终点时切换：  
  ```python
  current_level = 1
  walls = get_level1_walls()  # 初始加载第一关
  # 在主循环中检测是否到达终点（假设终点是(500, 300)的矩形）
  end_zone = pygame.Rect(500, 300, 50, 50)
  if player.colliderect(end_zone):
      current_level = 2
      walls = get_level2_walls()  # 切换到第二关
      player.x, player.y = 50, 50  # 重置角色位置
  ```  


## 三、练习题设计：分层任务+关卡创作（25分钟）  
## 基础任务（全员完成）：“不穿墙的迷宫”  
- 要求：基于角色移动代码，添加4面外围墙（顶部、底部、左右侧），实现“角色碰到墙就无法移动”的效果。  
- 关键步骤：  
  1. 定义`walls`列表（复制模块1的外围墙代码）；  
  2. 在移动后添加碰撞检测（复制模块2的回退逻辑）；  
  3. 绘制墙壁（在刷新画面时循环绘制）。  

## 进阶任务（选做）：“我的专属关卡”  
- 选项1：添加1-2面中间墙（如`pygame.Rect(200, 100, 20, 200)`），调整位置让迷宫有“一条通路”；  
- 选项2：设计终点区域（如红色矩形），到达后在屏幕上显示“通关啦！”（用`pygame.font`显示文字）；  
- 选项3：实现两关卡切换（参考模块3代码，第一关简单，第二关增加墙壁）。  

## 教师支持：  
- AI代码小助手提供“中间墙坐标计算”帮助（如“想在(200,100)加一面高200的墙，代码怎么写？”）；  
- 发放“关卡设计 Checklist”（墙壁是否闭合、通路是否存在、终点位置是否合理）。  


## 四、讲解与互评：从“能玩”到“好玩”（10分钟）  
1. **功能测试**：随机选3名学生演示代码，全班一起“玩”他们的迷宫，测试“是否穿墙”“能否到达终点”。  
2. **关卡点评**：从“难度合理性”“创意性”点评进阶任务，如“中间墙的位置让迷宫有了岔路，很有想法”。  
3. **小组投票**：评选“最想挑战的关卡”，作者获“关卡设计师”勋章。  


## 五、总结与作业（5分钟）  
## 课堂总结：  
- 墙壁=用`pygame.Rect`列表定义的“禁止区域”；  
- 碰撞检测=通过`collidelist()`判断角色与墙壁是否重叠，重叠则回退位置；  
- 关卡切换=用函数封装不同墙壁数据，通过条件触发切换。  

## 课后作业：  
1. 完善自己的迷宫关卡，至少包含5面墙和1个终点，截图记录“从起点到终点的路径”；  
2. 思考：“怎么让游戏有计分功能？（如移动步数越少，分数越高）”，下次课分享思路。  


## 教学理论支撑：  
1. **自我决定理论**：通过“自定义关卡”满足学生的自主性需求，“小组投票”增强胜任感，激发持续学习动机。  
2. **维果茨基最近发展区**：基础任务确保掌握核心逻辑（碰撞检测），进阶任务（多关卡、计分）挑战更高能力，教师通过Checklist提供针对性指导。  
3. **STEAM教育融合**：结合工程（关卡结构设计）、数学（坐标与矩形尺寸计算）、技术（Pygame进阶应用），培养系统思维与问题解决能力。