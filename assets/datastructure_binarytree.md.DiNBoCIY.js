import{j as n,c as a,b as l,ag as i}from"./chunks/framework.CPnt7f93.js";const p="/assets/full-tree01.D5HyQTvx.svg",e="/assets/full-tree02.CBt4Qxb4.png",r="data:image/gif;base64,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",t="/assets/tree_1.DpiQ-oLn.png",o="/assets/tree_2.BoenZQs4.png",g="/assets/tree_3.DBN29oL7.png",A="/assets/tree_4.BfkKX9LR.png",u="/assets/linkbtree.DZCMDiYd.jpg",I=JSON.parse('{"title":"二叉树","description":"","frontmatter":{},"headers":[],"relativePath":"datastructure/binarytree.md","filePath":"datastructure/binarytree.md","lastUpdated":1761651013000}'),c={name:"datastructure/binarytree.md"};function b(h,s,d,m,C,B){return l(),a("div",null,[...s[0]||(s[0]=[i('<h1 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#二叉树的性质">二叉树的性质</a></li><li><a href="#满二叉树">满二叉树</a></li><li><a href="#完全二叉树">完全二叉树</a></li><li><a href="#先序遍历">先序遍历</a></li><li><a href="#中序遍历">中序遍历</a></li><li><a href="#后序遍历">后序遍历</a></li><li><a href="#顺序存储">顺序存储</a></li><li><a href="#二叉树的高度">二叉树的高度</a></li><li><a href="#链式存储">链式存储</a></li></ul></nav><p>二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。 二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树 。</p><h3 id="二叉树的性质" tabindex="-1">二叉树的性质 <a class="header-anchor" href="#二叉树的性质" aria-label="Permalink to &quot;二叉树的性质&quot;">​</a></h3><p>性质一：在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）</p><p>性质二：深度为k的二叉树至多有2^k-1个结点（k&gt;0）</p><p>性质三：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</p><p>性质四：具有n个结点的完全二叉树的深度为floor(log2n)+1</p><h3 id="满二叉树" tabindex="-1">满二叉树 <a class="header-anchor" href="#满二叉树" aria-label="Permalink to &quot;满二叉树&quot;">​</a></h3><p>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。</p><p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p><p><img src="'+p+'" alt=""></p><h3 id="完全二叉树" tabindex="-1">完全二叉树 <a class="header-anchor" href="#完全二叉树" aria-label="Permalink to &quot;完全二叉树&quot;">​</a></h3><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><p>性质五：如果对一棵有n个结点的完全二叉树的结点按层序编号（从第一层开始到最下一层，每一层从左到右编号），对任一结点i有：</p><p>如果i=1 ，则结点为根结点，没有双亲。</p><p>如果2 * i &gt; n ，则结点i没有左孩子 ；否则其左孩子结点为2*i . （n为结点总数）</p><p>如果2 * i+1&gt;n ，则结点i没有右孩子；否则其右孩子结点为2*1+1</p><h4 id="完全二叉树的数组表示法" tabindex="-1">完全二叉树的数组表示法 <a class="header-anchor" href="#完全二叉树的数组表示法" aria-label="Permalink to &quot;完全二叉树的数组表示法&quot;">​</a></h4><p>二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。</p><p>普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些结点，将其”拼凑”成完全二叉树即可。如图 1 所示：</p><p><img src="'+e+'" alt=""></p><p>图 1 中，左侧是普通二叉树，右侧是转化后的完全（满）二叉树。</p><p>解决了二叉树的转化问题，接下来学习如何顺序存储完全（满）二叉树。</p><p>完全二叉树的顺序存储，仅需从根结点开始，按照层次依次将树中结点存储到数组即可。</p><p><img src="'+r+'" alt=""></p><h3 id="先序遍历" tabindex="-1">先序遍历 <a class="header-anchor" href="#先序遍历" aria-label="Permalink to &quot;先序遍历&quot;">​</a></h3><p>先序遍历是二叉树遍历的一种方式，它的遍历顺序是先访问根节点，然后递归地对左子树进行先序遍历，最后递归地对右子树进行先序遍历。下面是对先序遍历的详细讲解：</p><p><img src="'+t+`" alt=""></p><p>考虑以下二叉树：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-light vp-code" tabindex="0"><code><span class="line"><span>        9</span></span>
<span class="line"><span>       / \\</span></span>
<span class="line"><span>      7  16</span></span>
<span class="line"><span>     / \\   \\</span></span>
<span class="line"><span>    3  14  26</span></span>
<span class="line"><span>      /  / \\</span></span>
<span class="line"><span>     11 15  18</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>先序遍历的顺序是从根节点开始，按照根-左-右的顺序访问节点。</p><ol><li><p><strong>访问根节点 9</strong></p><ul><li>从根节点开始，首先访问根节点9。</li></ul></li><li><p><strong>递归访问左子树 7</strong></p><ul><li>移至左子树，访问左子树的根节点7。</li></ul></li><li><p><strong>递归访问左子树 3</strong></p><ul><li>移至左子树的左子树，访问左子树的左子树的根节点3。</li></ul></li><li><p><strong>回溯到左子树 3，递归访问右子树 11</strong></p><ul><li>3没有右子树，回溯到7，然后访问7的右子树，即11。</li></ul></li><li><p><strong>回溯到左子树 7，递归访问右子树 14</strong></p><ul><li>7的左子树已经访问完，回溯到9，然后访问9的右子树的根节点14。</li></ul></li><li><p><strong>递归访问左子树 11</strong></p><ul><li>移至右子树的左子树，访问右子树的左子树的根节点11。</li></ul></li><li><p><strong>回溯到右子树 11，递归访问右子树 15</strong></p><ul><li>11没有左子树和右子树，回溯到14，然后访问14的右子树的根节点15。</li></ul></li><li><p><strong>回溯到右子树 14，递归访问右子树 18</strong></p><ul><li>14的左子树已经访问完，回溯到9，然后访问9的右子树的根节点18。</li></ul></li><li><p><strong>递归访问右子树 16</strong></p><ul><li>移至右子树的根节点16。</li></ul></li><li><p><strong>递归访问左子树 15</strong></p></li></ol><ul><li>移至右子树的左子树，访问右子树的左子树的根节点15。</li></ul><ol start="11"><li><strong>回溯到右子树 15，递归访问右子树 26</strong></li></ol><ul><li>15没有左子树和右子树，回溯到16。</li></ul><ol start="12"><li><strong>回溯到根节点 16，递归访问右子树 26</strong></li></ol><ul><li>移至根节点的右子树，访问右子树的根节点26。</li></ul><ol start="13"><li><strong>回溯到根节点 9，遍历完成</strong></li></ol><ul><li>遍历完整个树。</li></ul><p>最终的先序遍历序列是：9, 7, 3, 11, 16, 14, 15, 18, 26。</p><h3 id="中序遍历" tabindex="-1">中序遍历 <a class="header-anchor" href="#中序遍历" aria-label="Permalink to &quot;中序遍历&quot;">​</a></h3><p>中序遍历是二叉树遍历的一种方式，它的遍历顺序是先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。下面是对中序遍历的详细讲解：</p><p><img src="`+o+`" alt=""></p><p>考虑以下二叉树：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-light vp-code" tabindex="0"><code><span class="line"><span>        9</span></span>
<span class="line"><span>       / \\</span></span>
<span class="line"><span>      7  16</span></span>
<span class="line"><span>     / \\   \\</span></span>
<span class="line"><span>    3  14  26</span></span>
<span class="line"><span>      /  / \\</span></span>
<span class="line"><span>     11 15  18</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>中序遍历的顺序是从最左子节点开始，按照左-根-右的顺序访问节点。</p><ol><li><p><strong>递归访问左子树 3</strong></p><ul><li>从最左子节点3开始，递归访问左子树。</li></ul></li><li><p><strong>递归访问左子树 7</strong></p><ul><li>移至左子树的根节点7，递归访问左子树。</li></ul></li><li><p><strong>递归访问左子树 11</strong></p><ul><li>移至左子树的根节点11，递归访问左子树。</li></ul></li><li><p><strong>回溯到左子树 11，访问根节点 11</strong></p><ul><li>11没有左子树，回溯到7，然后访问7。</li></ul></li><li><p><strong>递归访问右子树 14</strong></p><ul><li>移至右子树的根节点14，递归访问左子树。</li></ul></li><li><p><strong>回溯到右子树 14，访问根节点 14</strong></p><ul><li>14没有左子树，回溯到3，然后访问3。</li></ul></li><li><p><strong>回溯到根节点 3，访问根节点 3</strong></p><ul><li>3没有右子树，回溯到9，然后访问9。</li></ul></li><li><p><strong>递归访问右子树 16</strong></p><ul><li>移至右子树的根节点16，递归访问左子树。</li></ul></li><li><p><strong>递归访问左子树 15</strong></p><ul><li>移至左子树的根节点15，递归访问左子树。</li></ul></li><li><p><strong>回溯到左子树 15，访问根节点 15</strong></p><ul><li>15没有左子树，回溯到16，然后访问16。</li></ul></li><li><p><strong>递归访问右子树 18</strong></p><ul><li>移至右子树的根节点18，递归访问左子树。</li></ul></li><li><p><strong>回溯到右子树 18，访问根节点 18</strong></p><ul><li>18没有左子树，回溯到9，中序遍历完成。</li></ul></li></ol><p>最终的中序遍历序列是：3, 7, 11, 14, 15, 16, 18, 26。</p><h3 id="后序遍历" tabindex="-1">后序遍历 <a class="header-anchor" href="#后序遍历" aria-label="Permalink to &quot;后序遍历&quot;">​</a></h3><p>后序遍历是二叉树遍历的一种方式，它的遍历顺序是先递归地对左子树进行后序遍历，然后递归地对右子树进行后序遍历，最后访问根节点。下面是对后序遍历的详细讲解：</p><p><img src="`+g+`" alt=""></p><p>考虑以下二叉树：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-light vp-code" tabindex="0"><code><span class="line"><span>        9</span></span>
<span class="line"><span>       / \\</span></span>
<span class="line"><span>      7  16</span></span>
<span class="line"><span>     / \\   \\</span></span>
<span class="line"><span>    3  14  26</span></span>
<span class="line"><span>      /  / \\</span></span>
<span class="line"><span>     11 15  18</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>后序遍历的顺序是从最左子节点开始，按照左-右-根的顺序访问节点。</p><ol><li><p><strong>递归访问左子树 3</strong></p><ul><li>从最左子节点3开始，递归访问左子树。</li></ul></li><li><p><strong>递归访问左子树 11</strong></p><ul><li>移至左子树的根节点11，递归访问左子树。</li></ul></li><li><p><strong>回溯到左子树 11，访问右子树 3</strong></p><ul><li>11没有右子树，回溯到3，然后访问3的右子树。</li></ul></li><li><p><strong>递归访问右子树 7</strong></p><ul><li>移至右子树的根节点7，递归访问左子树。</li></ul></li><li><p><strong>递归访问左子树 14</strong></p><ul><li>移至左子树的根节点14，递归访问左子树。</li></ul></li><li><p><strong>回溯到左子树 14，访问右子树 7</strong></p><ul><li>14没有右子树，回溯到7，然后访问7的右子树。</li></ul></li><li><p><strong>回溯到右子树 7，访问根节点 7</strong></p><ul><li>7的左右子树都访问完，回溯到根节点9。</li></ul></li><li><p><strong>递归访问右子树 15</strong></p><ul><li>移至右子树的根节点15，递归访问左子树。</li></ul></li><li><p><strong>回溯到右子树 15，访问右子树 14</strong></p><ul><li>15没有左子树，回溯到14，然后访问14的右子树。</li></ul></li><li><p><strong>回溯到右子树 14，访问根节点 14</strong></p><ul><li>14的左右子树都访问完，回溯到根节点9。</li></ul></li><li><p><strong>回溯到根节点 9，访问右子树 18</strong></p><ul><li>移至右子树的根节点18，递归访问左子树。</li></ul></li><li><p><strong>递归访问左子树 26</strong></p><ul><li>移至左子树的根节点26，递归访问左子树。</li></ul></li><li><p><strong>回溯到左子树 26，访问右子树 18</strong></p><ul><li>26没有右子树，回溯到18，然后访问18的右子树。</li></ul></li><li><p><strong>回溯到右子树 18，访问根节点 18</strong></p><ul><li>18的左右子树都访问完，回溯到根节点9。</li></ul></li><li><p><strong>回溯到根节点 9，遍历完成</strong></p><ul><li>遍历完整个树。</li></ul></li></ol><p>最终的后序遍历序列是：3, 11, 7, 15, 14, 18, 26, 16, 9。</p><h3 id="顺序存储" tabindex="-1">顺序存储 <a class="header-anchor" href="#顺序存储" aria-label="Permalink to &quot;顺序存储&quot;">​</a></h3><p>二叉树的顺序存储是通过数组来表示二叉树的结构，具体的存储方式是按照二叉树的层次顺序，从上到下、从左到右，将每个节点按照这个顺序存储在数组中。</p><p><img src="`+A+`" alt=""></p><p>考虑以下二叉树：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-light vp-code" tabindex="0"><code><span class="line"><span>        1</span></span>
<span class="line"><span>       / \\</span></span>
<span class="line"><span>      2   3</span></span>
<span class="line"><span>     / \\   \\</span></span>
<span class="line"><span>    4   5   6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>对这棵二叉树进行顺序存储，将节点按照层次顺序从上到下、从左到右依次存储在数组中。对应的数组表示为：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-light vp-code" tabindex="0"><code><span class="line"><span>[1, 2, 3, 4, 5, #, 6]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="二叉树的高度" tabindex="-1">二叉树的高度 <a class="header-anchor" href="#二叉树的高度" aria-label="Permalink to &quot;二叉树的高度&quot;">​</a></h3><p>二叉树的高度是从根节点到最深叶子节点的最长路径的节点数。可以通过递归地计算左子树和右子树的高度，然后取较大值，再加上根节点的高度（1），得到整个二叉树的高度。</p><p>考虑以下二叉树：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-light vp-code" tabindex="0"><code><span class="line"><span>        9</span></span>
<span class="line"><span>       / \\</span></span>
<span class="line"><span>      7  16</span></span>
<span class="line"><span>     / \\   \\</span></span>
<span class="line"><span>    3  14  26</span></span>
<span class="line"><span>      /  / \\</span></span>
<span class="line"><span>     11 15  18</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>二叉树的高度为4，因为最长路径为根节点到叶子节点18的路径。</p><h3 id="链式存储" tabindex="-1">链式存储 <a class="header-anchor" href="#链式存储" aria-label="Permalink to &quot;链式存储&quot;">​</a></h3><p>在链式存储结构中，每个节点包含一个数据域和两个指针域，分别指向左子树和右子树。通过这种方式，可以用指针来表示二叉树的节点之间的关系。以下是一个链式存储的二叉树的例子：</p><div class="language-plaintext vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-light vp-code" tabindex="0"><code><span class="line"><span>    1</span></span>
<span class="line"><span>   / \\</span></span>
<span class="line"><span>  2   3</span></span>
<span class="line"><span> / \\</span></span>
<span class="line"><span>4   5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>对应的链式存储结构：</p><p><img src="`+u+'" alt=""></p><p>每个节点都包含一个数据域和两个指针域，例如：</p><ul><li>结点1：数据域为1，左指针指向结点2，右指针指向结点3。</li><li>结点2：数据域为2，左指针指向结点4，右指针指向结点5。</li><li>结点3：数据域为3，左指针和右指针均为空。</li><li>结点4：数据域为4，左指针和右指针均为空。</li><li>结点5：数据域为5，左指针和右指针均为空。</li></ul><p>在链式存储结构中，通过指针的连接关系表示了节点之间的层次和关联。这种结构更贴近二叉树的实际构造，更适用于动态的、频繁修改结构的场景。链式存储的优势在于它能够灵活地插入、删除节点，而不需要提前分配固定大小的存储空间。</p>',77)])])}const w=n(c,[["render",b]]);export{I as __pageData,w as default};
